!<arch>
__.PKGDEF       0           0     0     644     19583     `
go object darwin 386 go1.4.2 X:precisestack

$$
package ecdsa
	import crypto "crypto"
	import runtime "runtime"
	import io "io"
	import elliptic "crypto/elliptic"
	import asn1 "encoding/asn1"
	import big "math/big"
	type @"math/big".Word uintptr
	type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
	import rand "math/rand" // indirect
	type @"math/rand".Source interface { Int63() (? int64); Seed(@"math/rand".seed int64) }
	type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) ExpFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float32 () (? float32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Float64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int () (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31 () (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int31n (@"math/rand".nÂ·3 int32) (? int32)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63 () (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Int63n (@"math/rand".nÂ·3 int64) (? int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Intn (@"math/rand".nÂ·3 int) (? int)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) NormFloat64 () (? float64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Perm (@"math/rand".nÂ·3 int) (? []int)
	func (@"math/rand".rÂ·1 *@"math/rand".Rand) Seed (@"math/rand".seedÂ·2 int64)
	func (@"math/rand".rÂ·2 *@"math/rand".Rand) Uint32 () (? uint32)
	type @"io".RuneScanner interface { ReadRune() (@"io".r rune, @"io".size int, @"io".err error); UnreadRune() (? error) }
	type @"math/big".nat []@"math/big".Word
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".add (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".and (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".andNot (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bit (@"math/big".iÂ·3 uint) (? uint) { var @"math/big".jÂ·4 int; ; @"math/big".jÂ·4 = int(@"math/big".iÂ·3 / 0x20); if @"math/big".jÂ·4 >= len(@"math/big".zÂ·2) { return 0x0 }; return uint(@"math/big".zÂ·2[@"math/big".jÂ·4] >> (@"math/big".iÂ·3 % 0x20) & @"math/big".Word(0x1)) }
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".bitLen () (? int)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x0") @"math/big".bytes (@"math/big".bufÂ·3 []byte "esc:0x0") (@"math/big".iÂ·1 int)
	func (@"math/big".zÂ·1 @"math/big".nat "esc:0x0") @"math/big".clear ()
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".cmp (@"math/big".yÂ·3 @"math/big".nat "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".qÂ·1 @"math/big".nat) @"math/big".convertWords (@"math/big".sÂ·2 []byte "esc:0x0", @"math/big".charsetÂ·3 string "esc:0x0", @"math/big".bÂ·4 @"math/big".Word, @"math/big".ndigitsÂ·5 int, @"math/big".bbÂ·6 @"math/big".Word, @"math/big".tableÂ·7 []@"math/big".divisor "esc:0x0")
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".decimalString () (? string)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".div (@"math/big".z2Â·4 @"math/big".nat, @"math/big".uÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat "esc:0x2") @"math/big".divLarge (@"math/big".uÂ·4 @"math/big".nat, @"math/big".uInÂ·5 @"math/big".nat, @"math/big".vÂ·6 @"math/big".nat) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".nat)
	func (@"math/big".zÂ·3 @"math/big".nat) @"math/big".divW (@"math/big".xÂ·4 @"math/big".nat, @"math/big".yÂ·5 @"math/big".Word) (@"math/big".qÂ·1 @"math/big".nat, @"math/big".rÂ·2 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNN (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expNNWindowed (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat "esc:0x0", @"math/big".mÂ·5 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".expWW (@"math/big".xÂ·3 @"math/big".Word, @"math/big".yÂ·4 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".make (@"math/big".nÂ·3 int) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat) @"math/big".modW (@"math/big".dÂ·3 @"math/big".Word) (@"math/big".rÂ·1 @"math/big".Word)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mul (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulAddWW (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".Word, @"math/big".rÂ·5 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".mulRange (@"math/big".aÂ·3 uint64, @"math/big".bÂ·4 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".norm () (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".or (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".nÂ·2 @"math/big".nat) @"math/big".probablyPrime (@"math/big".repsÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".random (@"math/big".randÂ·3 *@"math/rand".Rand, @"math/big".limitÂ·4 @"math/big".nat "esc:0x0", @"math/big".nÂ·5 int) (? @"math/big".nat)
	func (@"math/big".zÂ·4 @"math/big".nat) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? @"math/big".nat, ? int, ? error)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".set (@"math/big".xÂ·3 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setBit (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".iÂ·4 uint, @"math/big".bÂ·5 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setUint64 (@"math/big".xÂ·3 uint64) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".setWord (@"math/big".xÂ·3 @"math/big".Word) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shl (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".shr (@"math/big".xÂ·3 @"math/big".nat, @"math/big".sÂ·4 uint) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".string (@"math/big".charsetÂ·3 string "esc:0x0") (? string)
	func (@"math/big".zÂ·2 @"math/big".nat) @"math/big".sub (@"math/big".xÂ·3 @"math/big".nat, @"math/big".yÂ·4 @"math/big".nat) (? @"math/big".nat)
	func (@"math/big".xÂ·2 @"math/big".nat "esc:0x0") @"math/big".trailingZeroBits () (? uint)
	func (@"math/big".zÂ·2 @"math/big".nat "esc:0x2") @"math/big".xor (@"math/big".xÂ·3 @"math/big".nat "esc:0x0", @"math/big".yÂ·4 @"math/big".nat "esc:0x0") (? @"math/big".nat)
	import fmt "fmt" // indirect
	type @"fmt".State interface { Flag(@"fmt".c int) (? bool); Precision() (@"fmt".prec int, @"fmt".ok bool); Width() (@"fmt".wid int, @"fmt".ok bool); Write(@"fmt".b []byte) (@"fmt".ret int, @"fmt".err error) }
	type @"fmt".ScanState interface { Read(@"fmt".buf []byte) (@"fmt".n int, @"fmt".err error); ReadRune() (@"fmt".r rune, @"fmt".size int, @"fmt".err error); SkipSpace(); Token(@"fmt".skipSpace bool, @"fmt".f func(? rune) (? bool)) (@"fmt".token []byte, @"fmt".err error); UnreadRune() (? error); Width() (@"fmt".wid int, @"fmt".ok bool) }
	type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
	func (@"math/big".zÂ·2 *@"math/big".Int) Abs (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Add (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) And (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) AndNot (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Binomial (@"math/big".nÂ·3 int64, @"math/big".kÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) Bit (@"math/big".iÂ·3 int) (? uint)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") BitLen () (? int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x1") Bits () (? []@"math/big".Word) { return @"math/big".xÂ·2.@"math/big".abs }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Bytes () (? []byte)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Cmp (@"math/big".yÂ·3 *@"math/big".Int "esc:0x0") (@"math/big".rÂ·1 int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Div (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) DivMod (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".mÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Exp (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int "esc:0x0", @"math/big".mÂ·5 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·1 *@"math/big".Int "esc:0x0") Format (@"math/big".sÂ·2 @"fmt".State, @"math/big".chÂ·3 rune)
	func (@"math/big".zÂ·2 *@"math/big".Int) GCD (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int, @"math/big".aÂ·5 *@"math/big".Int, @"math/big".bÂ·6 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) GobDecode (@"math/big".bufÂ·3 []byte "esc:0x0") (? error)
	func (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") GobEncode () (? []byte, ? error)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Int64 () (? int64)
	func (@"math/big".zÂ·2 *@"math/big".Int) Lsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalJSON () (? []byte, ? error)
	func (@"math/big".zÂ·3 *@"math/big".Int "esc:0x0") MarshalText () (@"math/big".textÂ·1 []byte, @"math/big".errÂ·2 error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mod (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) ModInverse (@"math/big".gÂ·3 *@"math/big".Int, @"math/big".nÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Mul (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) MulRange (@"math/big".aÂ·3 int64, @"math/big".bÂ·4 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Neg (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Not (@"math/big".xÂ·3 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Or (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int) ProbablyPrime (@"math/big".nÂ·3 int) (? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) Quo (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) QuoRem (@"math/big".xÂ·4 *@"math/big".Int, @"math/big".yÂ·5 *@"math/big".Int, @"math/big".rÂ·6 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rand (@"math/big".rndÂ·3 *@"math/rand".Rand, @"math/big".nÂ·4 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rem (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Rsh (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".nÂ·4 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) Scan (@"math/big".sÂ·3 @"fmt".ScanState, @"math/big".chÂ·4 rune) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Set (@"math/big".xÂ·3 *@"math/big".Int "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBit (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".iÂ·4 int, @"math/big".bÂ·5 uint) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int "esc:0x2") SetBits (@"math/big".absÂ·3 []@"math/big".Word) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetBytes (@"math/big".bufÂ·3 []byte "esc:0x0") (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetInt64 (@"math/big".xÂ·3 int64) (? *@"math/big".Int)
	func (@"math/big".zÂ·3 *@"math/big".Int) SetString (@"math/big".sÂ·4 string, @"math/big".baseÂ·5 int) (? *@"math/big".Int, ? bool)
	func (@"math/big".zÂ·2 *@"math/big".Int) SetUint64 (@"math/big".xÂ·3 uint64) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Sign () (? int) { if len(@"math/big".xÂ·2.@"math/big".abs) == 0x0 { return 0x0 }; if @"math/big".xÂ·2.@"math/big".neg { return -0x1 }; return 0x1 }
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") String () (? string)
	func (@"math/big".zÂ·2 *@"math/big".Int) Sub (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".xÂ·2 *@"math/big".Int "esc:0x0") Uint64 () (? uint64)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalJSON (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) UnmarshalText (@"math/big".textÂ·3 []byte) (? error)
	func (@"math/big".zÂ·2 *@"math/big".Int) Xor (@"math/big".xÂ·3 *@"math/big".Int, @"math/big".yÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·2 *@"math/big".Int) @"math/big".binaryGCD (@"math/big".aÂ·3 *@"math/big".Int, @"math/big".bÂ·4 *@"math/big".Int) (? *@"math/big".Int)
	func (@"math/big".zÂ·4 *@"math/big".Int) @"math/big".scan (@"math/big".rÂ·5 @"io".RuneScanner, @"math/big".baseÂ·6 int) (? *@"math/big".Int, ? int, ? error)
	type @"crypto/elliptic".CurveParams struct { P *@"math/big".Int; N *@"math/big".Int; B *@"math/big".Int; Gx *@"math/big".Int; Gy *@"math/big".Int; BitSize int }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Add (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int, @"crypto/elliptic".x2Â·6 *@"math/big".Int, @"crypto/elliptic".y2Â·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) Double (@"crypto/elliptic".x1Â·4 *@"math/big".Int, @"crypto/elliptic".y1Â·5 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams) IsOnCurve (@"crypto/elliptic".xÂ·3 *@"math/big".Int, @"crypto/elliptic".yÂ·4 *@"math/big".Int) (? bool)
	func (@"crypto/elliptic".curveÂ·2 *@"crypto/elliptic".CurveParams "esc:0x2") Params () (? *@"crypto/elliptic".CurveParams) { return @"crypto/elliptic".curveÂ·2 }
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarBaseMult (@"crypto/elliptic".kÂ·4 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) ScalarMult (@"crypto/elliptic".BxÂ·4 *@"math/big".Int, @"crypto/elliptic".ByÂ·5 *@"math/big".Int, @"crypto/elliptic".kÂ·6 []byte "esc:0x0") (? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".addJacobian (@"crypto/elliptic".x1Â·5 *@"math/big".Int, @"crypto/elliptic".y1Â·6 *@"math/big".Int, @"crypto/elliptic".z1Â·7 *@"math/big".Int, @"crypto/elliptic".x2Â·8 *@"math/big".Int, @"crypto/elliptic".y2Â·9 *@"math/big".Int, @"crypto/elliptic".z2Â·10 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·3 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".affineFromJacobian (@"crypto/elliptic".xÂ·4 *@"math/big".Int, @"crypto/elliptic".yÂ·5 *@"math/big".Int, @"crypto/elliptic".zÂ·6 *@"math/big".Int) (@"crypto/elliptic".xOutÂ·1 *@"math/big".Int, @"crypto/elliptic".yOutÂ·2 *@"math/big".Int)
	func (@"crypto/elliptic".curveÂ·4 *@"crypto/elliptic".CurveParams) @"crypto/elliptic".doubleJacobian (@"crypto/elliptic".xÂ·5 *@"math/big".Int, @"crypto/elliptic".yÂ·6 *@"math/big".Int, @"crypto/elliptic".zÂ·7 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
	type @"crypto/elliptic".Curve interface { Add(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".x2 *@"math/big".Int, @"crypto/elliptic".y2 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); Double(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); IsOnCurve(@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) (? bool); Params() (? *@"crypto/elliptic".CurveParams); ScalarBaseMult(@"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int); ScalarMult(@"crypto/elliptic".x1 *@"math/big".Int, @"crypto/elliptic".y1 *@"math/big".Int, @"crypto/elliptic".k []byte) (@"crypto/elliptic".x *@"math/big".Int, @"crypto/elliptic".y *@"math/big".Int) }
	type @"".PublicKey struct { ? @"crypto/elliptic".Curve; X *@"math/big".Int; Y *@"math/big".Int }
	type @"crypto".PublicKey interface {}
	type @"io".Reader interface { Read(@"io".p []byte) (@"io".n int, @"io".err error) }
	import hash "hash" // indirect
	type @"hash".Hash interface { BlockSize() (? int); Reset(); Size() (? int); Sum(@"hash".b []byte) (? []byte); Write(@"io".p []byte) (@"io".n int, @"io".err error) }
	type @"crypto".Hash uint
	func (@"crypto".hÂ·2 @"crypto".Hash) Available () (? bool) { return @"crypto".hÂ·2 < @"crypto".Hash(0xE) && @"crypto".hashes[@"crypto".hÂ·2] != nil }
	func (@"crypto".hÂ·2 @"crypto".Hash) HashFunc () (? @"crypto".Hash) { return @"crypto".hÂ·2 }
	func (@"crypto".hÂ·2 @"crypto".Hash) New () (? @"hash".Hash)
	func (@"crypto".hÂ·2 @"crypto".Hash) Size () (? int)
	type @"crypto".SignerOpts interface { HashFunc() (? @"crypto".Hash) }
	type @"".PrivateKey struct { ? @"".PublicKey; D *@"math/big".Int }
	func (@"".privÂ·2 *@"".PrivateKey "esc:0x2") Public () (? @"crypto".PublicKey) { return &@"".privÂ·2.PublicKey }
	func (@"".privÂ·3 *@"".PrivateKey) Sign (@"".randÂ·4 @"io".Reader, @"".msgÂ·5 []byte "esc:0x0", @"".optsÂ·6 @"crypto".SignerOpts "esc:0x0") (? []byte, ? error)
	func @"".GenerateKey (@"".cÂ·3 @"crypto/elliptic".Curve, @"".randÂ·4 @"io".Reader) (@"".privÂ·1 *@"".PrivateKey, @"".errÂ·2 error)
	func @"".Sign (@"".randÂ·4 @"io".Reader, @"".privÂ·5 *@"".PrivateKey, @"".hashÂ·6 []byte "esc:0x0") (@"".rÂ·1 *@"math/big".Int, @"".sÂ·2 *@"math/big".Int, @"".errÂ·3 error)
	func @"".Verify (@"".pubÂ·2 *@"".PublicKey, @"".hashÂ·3 []byte "esc:0x0", @"".rÂ·4 *@"math/big".Int, @"".sÂ·5 *@"math/big".Int) (? bool)
	func @"".init ()
	var @"crypto".hashes []func() (? @"hash".Hash)

$$
 _go_.8          0           0     0     644     80349     `
go object darwin 386 go1.4.2 X:precisestack

!
  go13ldcrypto.a"crypto/elliptic.aencoding/asn1.aio.amath/big.a ş."".(*PrivateKey).Public  `  Ze‹    ;awè    ëí‹\$ƒû t‰\$ÇD$    Ã‰ëï        0runtime.morestack_noctxt   H  $type.*"".PublicKey      "".~r0 *type.crypto.PublicKey "".priv  &type.*"".PrivateKey 0 0 
R  TgclocalsÂ·a08e9001cb8f9d822225de3b8e406515 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş*"".(*PrivateKey).Sign  À  ¸e‹    ;awè    ëíƒì8ÇD$\    ÇD$`    ÇD$d    ÇD$h    ÇD$l    ‹\$@‰$‹\$D‰\$‹\$<‰\$‹\$H‰\$‹\$L‰\$‹\$P‰\$è    ‹T$‹L$‹D$ ‹l$$‰l$,ƒø ‰D$(t$ÇD$\    ÇD$`    ÇD$d    ‰D$h‰l$lƒÄ8ÃÇD$0    ÇD$4    ‰T$0‰L$4Ç$    \$0‰\$è    \$‰Ş<$ü¥¥è    ‹t$‹l$‹T$‹L$‹D$‰t$\‰l$`‰T$d‰L$h‰D$lƒÄ8Ã        0runtime.morestack_noctxt   Ü  "".Sign   œ  ,type."".ecdsaSignature   ¶  runtime.convT2E   Ø  *encoding/asn1.Marshal   hp  "".autotmp_0004 ,type."".ecdsaSignature "".err type.error "".~r4 Xtype.error "".~r3 @type.[]uint8 "".opts 0,type.crypto.SignerOpts "".msg type.[]uint8 "".rand type.io.Reader "".priv  &type.*"".PrivateKey pœopho   b>H	$m  mmF TgclocalsÂ·df47e04495aeec9ad0763bc648c6b4e3 TgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş&"".randFieldElement  à  Îe‹    ;awè    ëíƒì0ÇD$H    ÇD$L    ÇD$D    ‹\$8‰$‹\$4‹[ ÿÓ‹D$‰D$ ‹h‰éÁùÁééÁùƒÁÇ$    ‰È™‰D$‰T$‰È™‰D$‰T$è    ‹T$‹L$‹D$‹\$<‰$‹\$@‰\$‰T$$‰T$‰L$(‰L$‰D$,‰D$è    ‹D$‹\$‰\$Lƒø ‰D$HtƒÄ0ÃÇ$    è    ‹\$‰$‹\$$‰\$‹\$(‰\$‹\$,‰\$è    ‹\$‰\$DÇ$    è    ‹\$‰$‹\$ ‹k‰l$‹    ‰\$è    ‹L$D‹D$‰$‰L$‰D$è    ‹D$D‰$‰D$‹    ‰\$è    ƒÄ0Ã         0runtime.morestack_noctxt   x 
      ¸  type.[]uint8   î  "runtime.makeslice   Ş  io.ReadFull     "type.math/big.Int   ¨  "runtime.newobject   ğ  0math/big.(*Int).SetBytes     "type.math/big.Int   ˜  "runtime.newobject   È  "".one   Ú  &math/big.(*Int).Sub   Š  &math/big.(*Int).Mod   ¬  "".one   ¾  &math/big.(*Int).Add   8`  "".autotmp_0013  type.int "".autotmp_0012  $type.*math/big.Int "".autotmp_0011  $type.*math/big.Int "".b type.[]uint8 "".params Btype.*crypto/elliptic.CurveParams "".err (type.error "".k  $type.*math/big.Int "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve `µ_`š_
 ğ .|.E8	85 " <:8%$!D TgclocalsÂ·808d8a83f3ee88717356789ffec2964a TgclocalsÂ·ad5dfc73494270c017e0b3c0d2659d72   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş"".GenerateKey  €  òe‹    ;awè    ëíƒì0ÇD$H    ÇD$L    ÇD$D    ‹\$4‰$‹\$8‰\$‹\$<‰\$‹\$@‰\$è    ‹\$‰\$‹D$‹\$‰\$Lƒø ‰D$HtƒÄ0ÃÇ$    è    ‹D$‰D$D‰$ƒ<$ „Ú   ‹\$4‰\$‹\$8‰\$è    ‹\$D‰$ƒ<$ „©   ƒ$‹\$‰\$è    ‹\$‰$è    ‹T$‹L$‹D$‰T$$‰T$‰L$(‰L$‰D$,‰D$‹\$8‰$‹\$4‹[$ÿÓ‹D$‹\$‰\$ ‹\$D‰$ƒ<$ t7ƒ$‰D$è    ‹\$D‰$ƒ<$ tƒ$‹\$ ‰\$è    ƒÄ0Ã‰    ëã‰    ëÁ‰    éLÿÿÿ‰    éÿÿÿ        0runtime.morestack_noctxt   œ  &"".randFieldElement   ì  $type."".PrivateKey   ö  "runtime.newobject   Ê  2runtime.writebarrieriface     .runtime.writebarrierptr   ¦  *math/big.(*Int).Bytes   ’ 
      Ú  .runtime.writebarrierptr   –  .runtime.writebarrierptr   8`  "".autotmp_0025 $type.*math/big.Int "".autotmp_0023 type.[]uint8 "".k '$type.*math/big.Int "".err (type.error "".priv  &type.*"".PrivateKey "".rand type.io.Reader "".c  4type.crypto/elliptic.Curve `\_`ß_`- € 6œ.8	&"„  M-*.Z6 TgclocalsÂ·6fb4fb63b12ef264578672d24f7e049a TgclocalsÂ·b44d60a42acfad6fdbfa8904402ef0a6   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş"".hashToInt  À  ¼e‹    ;awè    ëíƒì‹\$0‰$‹\$,‹[ ÿÓ‹\$‹k‰,$è    ‹\$‰\$ƒÃ‰ØÁûÁëÃÁû‹L$$9Ùƒ   ‹L$(9Ùrt‹T$ ‰T$ ‰\$$‰L$(Ç$    è    ‹\$‰$‹\$ ‰\$‹\$$‰\$‹\$(‰\$è    ‹L$‹D$$Áà+D$ƒø ~‰$‰L$‰L$‰D$è    ‹L$‰L$4ƒÄÃè    ë“        0runtime.morestack_noctxt   H 
      b  ,math/big.(*Int).BitLen   è  "type.math/big.Int   ò  "runtime.newobject   º  0math/big.(*Int).SetBytes   Š  &math/big.(*Int).Rsh   ¬  $runtime.panicslice   08  "".autotmp_0032  type.int "".autotmp_0031  type.int "".autotmp_0028  type.int "".ret $type.*math/big.Int "".orderBits type.int "".~r2 ($type.*math/big.Int "".c 4type.crypto/elliptic.Curve "".hash  type.[]uint8 8¾78 à 4Â#4  $  TgclocalsÂ·d4064a15a268e69e05eeeca6eb6f8ff6 TgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş "".fermatInverse  À  ¼e‹    ;awè    ëíƒìÇ$   ÇD$    è    ‹\$‰\$Ç$    è    ‹\$‰$‹\$$‰\$‹\$‰\$è    ‹\$‰\$Ç$    è    ‹\$‰$‹\$ ‰\$‹\$‰\$‹\$$‰\$è    ‹\$‰\$(ƒÄÃ        0runtime.morestack_noctxt   L  math/big.NewInt   j  "type.math/big.Int   t  "runtime.newobject   ¬  &math/big.(*Int).Sub   Ê  "type.math/big.Int   Ô  "runtime.newobject   œ  &math/big.(*Int).Exp   8  "".autotmp_0048  $type.*math/big.Int "".autotmp_0047  $type.*math/big.Int "".autotmp_0045  $type.*math/big.Int "".nMinus2 $type.*math/big.Int "".two $type.*math/big.Int "".~r2 $type.*math/big.Int "".N $type.*math/big.Int "".k  $type.*math/big.Int 8‡7   è0>  %$ TgclocalsÂ·3cd76c4f8d01c613585e17871258aa07 TgclocalsÂ·fd4b7947caa1e98312cfd5cb0fa3bc84   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş"".Sign   	  	e‹    ;awè    ëíƒìHÇD$l    ÇD$p    ÇD$h    ‹\$Tƒû „  ‹‹k‰l$0‰,$‰L$,‹Y ÿÓ‹\$‹k‰l$(‹\$,‰$‹\$0‰\$‹\$L‰\$‹\$P‰\$è    ‹D$‹L$‹\$‰\$pƒù ‰L$ltÇD$d    ƒÄHÃ‰D$ ‰$‹\$(‰\$è    ‹\$‰\$‹\$ ‰$è    ‹|$‹t$‹T$‹\$Tƒû „\  ‹‹k‰|$<‰|$‰t$@‰t$‰T$D‰T$‰l$8‰,$‰L$4‹Y$ÿÓ‹D$‰$‰D$d‰D$‹\$(‰\$è    ‹D$d‹hƒı …ç   1Àƒø „ÿÿÿ‹\$X‰$‹\$\‰\$‹\$`‰\$‹\$,‰\$‹\$0‰\$è    ‹\$‰\$$Ç$    è    ‹\$‰$‹\$T‹k‰l$‹\$d‰\$è    ‹D$‰$‰D$h‰D$‹\$$‰\$è    ‹D$h‰$‰D$‹\$‰\$è    ‹D$h‰$‰D$‹\$(‰\$è    ‹D$h‹hƒı u1Àƒø „PşÿÿƒÄHÃ¶€û t¸ÿÿÿÿëä¸   ëİ¶€û t
¸ÿÿÿÿé	ÿÿÿ¸   éÿşÿÿ‰éşÿÿ‰éìıÿÿ        0runtime.morestack_noctxt   œ 
      ö  &"".randFieldElement   è   "".fermatInverse     *math/big.(*Int).Bytes     
      Ô  &math/big.(*Int).Mod   â  "".hashToInt   €  "type.math/big.Int   Š  "runtime.newobject   È  &math/big.(*Int).Mul   €  &math/big.(*Int).Add   °  &math/big.(*Int).Mul   à  &math/big.(*Int).Mod   P  "".autotmp_0056  type.int "".autotmp_0054  $type.*math/big.Int "".autotmp_0053  $type.*math/big.Int "".autotmp_0051 type.[]uint8 "".e G$type.*math/big.Int "".kInv W$type.*math/big.Int "".k O$type.*math/big.Int "".N ?$type.*math/big.Int "".c 74type.crypto/elliptic.Curve "".err @type.error "".s 8$type.*math/big.Int "".r 0$type.*math/big.Int "".hash type.[]uint8 "".priv &type.*"".PrivateKey "".rand  type.io.Reader (êA Ğ \ü.
4	V
4/
	 * N,9bG;y TgclocalsÂ·275557840777af8ce3b59686ef521191 TgclocalsÂ·cb642a313c683b350cd167d798ceb596   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş"".Verify     ˆe‹    ;awè    ëíƒìT‹\$Xƒû „  ‹‹k‰l$D‰,$‰L$@‹Y ÿÓ‹T$h‹\$‹s‹jƒı …Ò  1Àƒø „¢  ‹D$l‹hƒı …›  1Àƒø „‡  ‰$‰t$<‰t$è    ‹\$ƒû a  ‹\$l‰$‹\$<‰\$è    ‹\$ƒû @  ‹\$\‰$‹\$`‰\$‹\$d‰\$‹\$@‰\$‹\$D‰\$è    ‹\$‰\$8Ç$    è    ‹\$‰$‹\$l‰\$‹\$<‰\$è    ‹L$8‹D$‰$‰L$‰D$,‰D$è    ‹D$‰$‰D$4‰D$‹\$<‰\$è    ‹D$,‰$‹\$h‰\$‰D$è    ‹D$‰$‰D$0‰D$‹\$<‰\$è    ‹\$4‰$è    ‹T$‹L$‹D$‰T$H‰T$‰L$L‰L$‰D$P‰D$‹\$D‰$‹\$@‹[$ÿÓ‹\$‰\$$‹\$‰\$ ‹\$0‰$è    ‹t$X‹T$‹L$‹D$‹n‰l$‹n‰l$‰T$H‰T$‰L$L‰L$‰D$P‰D$‹\$D‰$‹\$@‹[(ÿÓ‹L$‹D$‹\$$‰\$‹\$ ‰\$‰L$‰D$‹\$D‰$‹\$@‹[ÿÓ‹L$‹T$‹iƒı uz1Àƒø u‹jƒı uU1Àƒø u	ÆD$p ƒÄTÃ‰$‰L$(‰L$‹\$<‰\$è    ‹\$(‰$‹\$h‰\$è    ‹\$ƒû t	ÆD$p ƒÄTÃÆD$pëõ¶€û t¸ÿÿÿÿë¸   ë—¶€û t
¸ÿÿÿÿévÿÿÿ¸   élÿÿÿÆD$p ƒÄTÃÆD$p ƒÄTÃ¶€û t
¸ÿÿÿÿéUıÿÿ¸   éKıÿÿ¶€û t
¸ÿÿÿÿéıÿÿ¸   éıÿÿ‰éßüÿÿ(        0runtime.morestack_noctxt   l 
      ‚  &math/big.(*Int).Cmp   Ä  &math/big.(*Int).Cmp   ¶  "".hashToInt   Ô  "type.math/big.Int   Ş  "runtime.newobject   –  4math/big.(*Int).ModInverse   Î  &math/big.(*Int).Mul   †  &math/big.(*Int).Mod   ¶  &math/big.(*Int).Mul   î  &math/big.(*Int).Mod   †  *math/big.(*Int).Bytes   ò 
      ¦  *math/big.(*Int).Bytes   ¶ 
      –	 
       
  &math/big.(*Int).Mod   È
  &math/big.(*Int).Cmp   8¨  0"".autotmp_0074  type.int "".autotmp_0073  type.int "".autotmp_0072  type.int "".autotmp_0071  type.[]uint8 "".autotmp_0070 type.[]uint8 "".autotmp_0069  $type.*math/big.Int "".autotmp_0068  $type.*math/big.Int "".autotmp_0066  $type.*math/big.Int "".autotmp_0063  type.int "".autotmp_0062  type.int "".x W$type.*math/big.Int 
"".y1 g$type.*math/big.Int 
"".x1 _$type.*math/big.Int 
"".u2 G$type.*math/big.Int 
"".u1 ?$type.*math/big.Int "".w O$type.*math/big.Int "".e 7$type.*math/big.Int "".N /$type.*math/big.Int "".c '4type.crypto/elliptic.Curve "".~r4 0type.bool "".s ($type.*math/big.Int "".r  $type.*math/big.Int "".hash type.[]uint8 "".pub  $type.*"".PublicKey >¨å§¨=§¨A§¨§¨K Ğ `Æ2>40PZ0	-2		8 8 6Jn8PyD­ TgclocalsÂ·8079dab6f601396bca1f5af3d7ec60a6 TgclocalsÂ·2a6a26631730f601ffb9dadc3e33c5c5   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş"".init  À  ¸e‹    ;awè    ëíƒì€=     t€=    uƒÄÃè    Æ    è    è    è    è    è    Ç$    è    ‹\$‰$ÇD$   ÇD$    è    ‹D$    ‰$‰D$è    Æ    ƒÄÃ"        0runtime.morestack_noctxt   0  "".initdoneÂ·   B  "".initdoneÂ·   Z  "runtime.throwinit   j  "".initdoneÂ·   v  math/big.init   €  io.init   Š  $encoding/asn1.init   ”  (crypto/elliptic.init     crypto.init   ¬  "type.math/big.Int   ¶  "runtime.newobject   î  0math/big.(*Int).SetInt64   ‚  "".one   š  .runtime.writebarrierptr   ¦  "".initdoneÂ·          o   üS‡>ˆ 
 ,t TgclocalsÂ·3280bececceccd33cb74587feedb1f9f TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş.type..hash."".PublicKey €  üe‹    ;awè    ëíƒì‹\$‰$ƒ<$ tSÇD$   ‹\$‰\$è    ‹D$‹\$‰$ƒ<$ t%ƒ$ÇD$   ‰D$‰D$è    ‹\$‰\$ ƒÄÃ‰    ëÓ‰    ë¥        0runtime.morestack_noctxt   h  "runtime.interhash   ¼  runtime.memhash       
"".autotmp_0082  type.uintptr "".~r3 type.uintptr "".h type.uintptr "".s type.uintptr "".p  $type.*"".PublicKey  W  € € 
 3M TgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş*type..eq."".PublicKey €  îe‹    ;awè    ëíƒì$‹\$,ƒû „   ‹3‹k‰l$ ‹\$(ƒû tw‹‹{9òue‰T$‰$‰|$‰|$‰t$‰t$‹l$ ‰l$è    ‹t$,‹T$(¶\$€û t/‹J‹n9ét	ÆD$4 ƒÄ$Ã‹J‹n9ét	ÆD$4 ƒÄ$ÃÆD$4ƒÄ$ÃÆD$4 ƒÄ$Ã‰ë…‰élÿÿÿ        0runtime.morestack_noctxt   ¼  runtime.ifaceeq    H  "".autotmp_0084 4type.crypto/elliptic.Curve "".autotmp_0083 4type.crypto/elliptic.Curve "".~r3 type.bool "".s type.uintptr "".q $type.*"".PublicKey "".p  $type.*"".PublicKey *HpGHGHGHGH À À 
 ]c TgclocalsÂ·9c703c5c7b9c1932c840b69f8ebce236 TgclocalsÂ·44568aa369055d8938d809aa5d80843b   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş&"".(*PublicKey).Add €  úe‹    ;awè    ëíƒì$‹Y…Ût
|$(9;u‰#‹\$(ƒû tI‹‹k‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰l$ ‰,$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄ$Ã‰ë³        0runtime.morestack_noctxt   Æ 
      8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey HbGH € € 
 c TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş "".PublicKey.Add €  æe‹    ;awè    ëíƒì$‹Y…Ût
|$(9;u‰#‹L$(‹D$,‹\$8‰\$‹\$<‰\$‹\$@‰\$‹\$D‰\$‰D$ ‰$‰L$‹YÿÓ‹L$‹D$‰L$H‰D$LƒÄ$Ã        0runtime.morestack_noctxt   º 
      PH  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int $crypto/elliptic.y2 8$type.*math/big.Int $crypto/elliptic.x2 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey H\G € € 
 ]# TgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".(*PublicKey).Double à  Úe‹    ;awè    ëíƒì‹Y…Ût
|$ 9;u‰#‹\$ ƒû t9‹‹k‹\$$‰\$‹\$(‰\$‰l$‰,$‰L$‹YÿÓ‹L$‹D$‰L$,‰D$0ƒÄÃ‰ëÃ        0runtime.morestack_noctxt   ¦ 
      (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey 8R78 p p 
 S TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş&"".PublicKey.Double à  Æe‹    ;awè    ëíƒì‹Y…Ût
|$ 9;u‰#‹L$ ‹D$$‹\$0‰\$‹\$4‰\$‰D$‰$‰L$‹YÿÓ‹L$‹D$‰L$8‰D$<ƒÄÃ        0runtime.morestack_noctxt   š 
      @8  
"crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey 8L7 p 
p 
 M# TgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş2"".(*PublicKey).IsOnCurve à  Ìe‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹\$ƒû t2‹‹k‹\$ ‰\$‹\$$‰\$‰l$‰,$‰L$‹YÿÓ¶\$ˆ\$(ƒÄÃ‰ëÊ        0runtime.morestack_noctxt   ¦ 
       0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  $type.*"".PublicKey 0K/0 p p 
 S TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".PublicKey.IsOnCurve À  ¸e‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹L$‹D$ ‹\$,‰\$‹\$0‰\$‰D$‰$‰L$‹YÿÓ¶\$ˆ\$4ƒÄÃ        0runtime.morestack_noctxt   š 
      80  "".~r3 0type.bool "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int ""..this  "type."".PublicKey 0E/ ` ` 
 M TgclocalsÂ·533e41f03c38242213357bdf241c642f TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş,"".(*PublicKey).Params À  ªe‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹\$ƒû t!‹‹k‰l$‰,$‰L$‹Y ÿÓ‹\$‰\$ƒÄÃ‰ëÛ        0runtime.morestack_noctxt   † 
         "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  $type.*"".PublicKey  :  ` ` 
 C TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş&"".PublicKey.Params    –e‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹L$‹D$‰D$‰$‰L$‹Y ÿÓ‹\$‰\$$ƒÄÃ        0runtime.morestack_noctxt   z 
      (   "".~r1  Btype.*crypto/elliptic.CurveParams ""..this  "type."".PublicKey  4 P P 
 = TgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş<"".(*PublicKey).ScalarBaseMult €  êe‹    ;awè    ëíƒì ‹Y…Ût
|$$9;u‰#‹\$$ƒû tA‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‰l$‰,$‰L$‹Y$ÿÓ‹L$‹D$‰L$4‰D$8ƒÄ Ã‰ë»        0runtime.morestack_noctxt   ¶ 
      0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  $type.*"".PublicKey @Z?@ € € 
 [% TgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş6"".PublicKey.ScalarBaseMult à  Öe‹    ;awè    ëíƒì ‹Y…Ût
|$$9;u‰#‹L$$‹D$(‹\$4‰\$‹\$8‰\$‹\$<‰\$‰D$‰$‰L$‹Y$ÿÓ‹L$‹D$‰L$@‰D$DƒÄ Ã        0runtime.morestack_noctxt   ª 
      H@  "crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int "crypto/elliptic.k  type.[]uint8 ""..this  "type."".PublicKey @T? p p 
 U TgclocalsÂ·f4b5958521e1cb5f3b2f5fb10ef93ae8 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş4"".(*PublicKey).ScalarMult    Še‹    ;awè    ëíƒì(‹Y…Ût
|$,9;u‰#‹\$,ƒû tQ‹‹k‹\$0‰\$‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‰l$$‰,$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$D‰D$HƒÄ(Ã‰ë«        0runtime.morestack_noctxt   Ö 
      @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  $type.*"".PublicKey PjOP   
 k% TgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".PublicKey.ScalarMult €  öe‹    ;awè    ëíƒì(‹Y…Ût
|$,9;u‰#‹L$,‹D$0‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‹\$L‰\$‰D$$‰$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$P‰D$TƒÄ(Ã        0runtime.morestack_noctxt   Ê 
      XP  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int "crypto/elliptic.k 0type.[]uint8 $crypto/elliptic.y1 ($type.*math/big.Int $crypto/elliptic.x1  $type.*math/big.Int ""..this  "type."".PublicKey PdO € € 
 e TgclocalsÂ·464a8fa94b68a24c95c5f7d743fa1b72 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş0type..hash."".PrivateKey €  üe‹    ;awè    ëíƒì‹\$‰$ƒ<$ tSÇD$   ‹\$‰\$è    ‹D$‹\$‰$ƒ<$ t%ƒ$ÇD$   ‰D$‰D$è    ‹\$‰\$ ƒÄÃ‰    ëÓ‰    ë¥        0runtime.morestack_noctxt   h  .type..hash."".PublicKey   ¼  runtime.memhash       
"".autotmp_0124  type.uintptr "".~r3 type.uintptr "".h type.uintptr "".s type.uintptr "".p  &type.*"".PrivateKey  W  € € 
 3M TgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783 TgclocalsÂ·3280bececceccd33cb74587feedb1f9f   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş,type..eq."".PrivateKey    e‹    ;awè    ëíƒì,‹L$0ƒù „¥   ‹D$4ƒø „‘   ‰D$‹0‹h‰l$(‰L$‹‹y9òun‰T$‰$‰|$ ‰|$‰t$$‰t$‹l$(‰l$è    ‹t$‹T$¶\$€û t8‹N‹j9éu.‹N‹j9éu$‹\$0‹K‹\$4‹k9ét	ÆD$< ƒÄ,ÃÆD$<ƒÄ,ÃÆD$< ƒÄ,Ã‰ éhÿÿÿ‰éTÿÿÿ        0runtime.morestack_noctxt   Ô  runtime.ifaceeq    X  "".autotmp_0128 4type.crypto/elliptic.Curve "".autotmp_0127 4type.crypto/elliptic.Curve "".autotmp_0126 /$type.*"".PublicKey "".autotmp_0125 '$type.*"".PublicKey "".~r3 type.bool "".s type.uintptr "".q &type.*"".PrivateKey "".p  &type.*"".PrivateKey $X˜WXWXWX Ğ Ğ 
 ig TgclocalsÂ·fa7203fd5ed88aea99b7be572f707eb0 TgclocalsÂ·65526a5f07004f02424fe51b799cdd23   N/usr/local/go/src/crypto/ecdsa/ecdsa.goş("".(*PrivateKey).Add €  úe‹    ;awè    ëíƒì$‹Y…Ût
|$(9;u‰#‹\$(ƒû tI‹‹k‹\$,‰\$‹\$0‰\$‹\$4‰\$‹\$8‰\$‰l$ ‰,$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄ$Ã‰ë³        0runtime.morestack_noctxt   Æ 
      8H  "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int $crypto/elliptic.y2  $type.*math/big.Int $crypto/elliptic.x2 $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey HbGH € € 
 c TgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş""".PrivateKey.Add €  æe‹    ;awè    ëíƒì$‹Y…Ût
|$(9;u‰#‹L$(‹D$,‹\$<‰\$‹\$@‰\$‹\$D‰\$‹\$H‰\$‰D$ ‰$‰L$‹YÿÓ‹L$‹D$‰L$L‰D$PƒÄ$Ã        0runtime.morestack_noctxt   º 
      XH  "crypto/elliptic.y P$type.*math/big.Int "crypto/elliptic.x H$type.*math/big.Int $crypto/elliptic.y2 @$type.*math/big.Int $crypto/elliptic.x2 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey H\G € € 
 ]# TgclocalsÂ·d0639bedff7ffedcd56695753d30706e TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".(*PrivateKey).Double à  Úe‹    ;awè    ëíƒì‹Y…Ût
|$ 9;u‰#‹\$ ƒû t9‹‹k‹\$$‰\$‹\$(‰\$‰l$‰,$‰L$‹YÿÓ‹L$‹D$‰L$,‰D$0ƒÄÃ‰ëÃ        0runtime.morestack_noctxt   ¦ 
      (8  
"crypto/elliptic.y  $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey 8R78 p  p 
 S TgclocalsÂ·6e5d4a330d25067342b1b461a5d19024 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş("".PrivateKey.Double à  Æe‹    ;awè    ëíƒì‹Y…Ût
|$ 9;u‰#‹L$ ‹D$$‹\$4‰\$‹\$8‰\$‰D$‰$‰L$‹YÿÓ‹L$‹D$‰L$<‰D$@ƒÄÃ        0runtime.morestack_noctxt   š 
      H8  
"crypto/elliptic.y @$type.*math/big.Int "crypto/elliptic.x 8$type.*math/big.Int $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey 8L7 p "p 
 M# TgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş4"".(*PrivateKey).IsOnCurve à  Ìe‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹\$ƒû t2‹‹k‹\$ ‰\$‹\$$‰\$‰l$‰,$‰L$‹YÿÓ¶\$ˆ\$(ƒÄÃ‰ëÊ        0runtime.morestack_noctxt   ¦ 
       0  "".~r3 type.bool "crypto/elliptic.y $type.*math/big.Int "crypto/elliptic.x $type.*math/big.Int ""..this  &type.*"".PrivateKey 0K/0 p $p 
 S TgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".PrivateKey.IsOnCurve À  ¸e‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹L$‹D$ ‹\$0‰\$‹\$4‰\$‰D$‰$‰L$‹YÿÓ¶\$ˆ\$8ƒÄÃ        0runtime.morestack_noctxt   š 
      @0  "".~r3 8type.bool "crypto/elliptic.y 0$type.*math/big.Int "crypto/elliptic.x ($type.*math/big.Int ""..this  $type."".PrivateKey 0E/ ` &` 
 M TgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş."".(*PrivateKey).Params À  ªe‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹\$ƒû t!‹‹k‰l$‰,$‰L$‹Y ÿÓ‹\$‰\$ƒÄÃ‰ëÛ        0runtime.morestack_noctxt   † 
         "".~r1 Btype.*crypto/elliptic.CurveParams ""..this  &type.*"".PrivateKey  :  ` (` 
 C TgclocalsÂ·06cab038d51064a089bda21fa03e00f7 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş("".PrivateKey.Params    –e‹    ;awè    ëíƒì‹Y…Ût
|$9;u‰#‹L$‹D$‰D$‰$‰L$‹Y ÿÓ‹\$‰\$(ƒÄÃ        0runtime.morestack_noctxt   z 
      0   "".~r1 (Btype.*crypto/elliptic.CurveParams ""..this  $type."".PrivateKey  4 P *P 
 = TgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş>"".(*PrivateKey).ScalarBaseMult €  êe‹    ;awè    ëíƒì ‹Y…Ût
|$$9;u‰#‹\$$ƒû tA‹‹k‹\$(‰\$‹\$,‰\$‹\$0‰\$‰l$‰,$‰L$‹Y$ÿÓ‹L$‹D$‰L$4‰D$8ƒÄ Ã‰ë»        0runtime.morestack_noctxt   ¶ 
      0@  "crypto/elliptic.y ($type.*math/big.Int "crypto/elliptic.x  $type.*math/big.Int "crypto/elliptic.k type.[]uint8 ""..this  &type.*"".PrivateKey @Z?@ € ,€ 
 [% TgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş8"".PrivateKey.ScalarBaseMult à  Öe‹    ;awè    ëíƒì ‹Y…Ût
|$$9;u‰#‹L$$‹D$(‹\$8‰\$‹\$<‰\$‹\$@‰\$‰D$‰$‰L$‹Y$ÿÓ‹L$‹D$‰L$D‰D$HƒÄ Ã        0runtime.morestack_noctxt   ª 
      P@  "crypto/elliptic.y H$type.*math/big.Int "crypto/elliptic.x @$type.*math/big.Int "crypto/elliptic.k (type.[]uint8 ""..this  $type."".PrivateKey @T? p .p 
 U TgclocalsÂ·fb6dce094c1dd234d359f74ad2ce663f TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş6"".(*PrivateKey).ScalarMult    Še‹    ;awè    ëíƒì(‹Y…Ût
|$,9;u‰#‹\$,ƒû tQ‹‹k‹\$0‰\$‹\$4‰\$‹\$8‰\$‹\$<‰\$‹\$@‰\$‰l$$‰,$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$D‰D$HƒÄ(Ã‰ë«        0runtime.morestack_noctxt   Ö 
      @P  "crypto/elliptic.y 8$type.*math/big.Int "crypto/elliptic.x 0$type.*math/big.Int "crypto/elliptic.k type.[]uint8 $crypto/elliptic.y1 $type.*math/big.Int $crypto/elliptic.x1 $type.*math/big.Int ""..this  &type.*"".PrivateKey PjOP  0 
 k% TgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2 TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>ş0"".PrivateKey.ScalarMult €  öe‹    ;awè    ëíƒì(‹Y…Ût
|$,9;u‰#‹L$,‹D$0‹\$@‰\$‹\$D‰\$‹\$H‰\$‹\$L‰\$‹\$P‰\$‰D$$‰$‰L$ ‹Y(ÿÓ‹L$‹D$‰L$T‰D$XƒÄ(Ã        0runtime.morestack_noctxt   Ê 
      `P  "crypto/elliptic.y X$type.*math/big.Int "crypto/elliptic.x P$type.*math/big.Int "crypto/elliptic.k 8type.[]uint8 $crypto/elliptic.y1 0$type.*math/big.Int $crypto/elliptic.x1 ($type.*math/big.Int ""..this  $type."".PrivateKey PdO € 2€ 
 e TgclocalsÂ·820c449159202a11cc0e8f118b89b1ba TgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3   <autogenerated>şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·a08e9001cb8f9d822225de3b8e406515             şTgclocalsÂ·1c5b1c90a4c2549bb9ca6a7854f35d0e                    şTgclocalsÂ·df47e04495aeec9ad0763bc648c6b4e3           ®°  ®°   şTgclocalsÂ·ad5dfc73494270c017e0b3c0d2659d72 P  P                 
   
              şTgclocalsÂ·808d8a83f3ee88717356789ffec2964a P  P      »   »  »  »  »,  »,  ».  ».   şTgclocalsÂ·b44d60a42acfad6fdbfa8904402ef0a6 @  @   
                         şTgclocalsÂ·6fb4fb63b12ef264578672d24f7e049a @  @      »   »  »,  ».  ».  ».   şTgclocalsÂ·e1ae6533a9e39048ba0735a2264ce16a                   şTgclocalsÂ·d4064a15a268e69e05eeeca6eb6f8ff6           Â  Â   şTgclocalsÂ·fd4b7947caa1e98312cfd5cb0fa3bc84 (  (                 şTgclocalsÂ·3cd76c4f8d01c613585e17871258aa07 (  (      
   
   
    şTgclocalsÂ·cb642a313c683b350cd167d798ceb596 X  X	             €  ˆ  ‚  ‚  ‚  ¢  €   şTgclocalsÂ·275557840777af8ce3b59686ef521191 X  X	      «   «€  «€  «€ «€ «  «  «  «   şTgclocalsÂ·2a6a26631730f601ffb9dadc3e33c5c5 p  p              €    €€ €ˆ  ˆ  Š  ‚ 
€  €       şTgclocalsÂ·8079dab6f601396bca1f5af3d7ec60a6 p  p      

  

  

  

  

  

  

  

  

  

  

  

   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           ş*"".one  $type.*math/big.Int   ş,"".initdoneÂ·  type.uint8   ş4"".(*PrivateKey).PublicÂ·f          ."".(*PrivateKey).Public   ş,runtime.throwreturnÂ·f          &runtime.throwreturn   ş0"".(*PrivateKey).SignÂ·f          *"".(*PrivateKey).Sign   ş"".SignÂ·f          "".Sign   ş$runtime.convT2EÂ·f          runtime.convT2E   ş0encoding/asn1.MarshalÂ·f          *encoding/asn1.Marshal   ş,"".randFieldElementÂ·f          &"".randFieldElement   ş(runtime.makesliceÂ·f          "runtime.makeslice   şio.ReadFullÂ·f          io.ReadFull   ş(runtime.newobjectÂ·f          "runtime.newobject   ş6math/big.(*Int).SetBytesÂ·f          0math/big.(*Int).SetBytes   ş,math/big.(*Int).SubÂ·f          &math/big.(*Int).Sub   ş,math/big.(*Int).ModÂ·f          &math/big.(*Int).Mod   ş,math/big.(*Int).AddÂ·f          &math/big.(*Int).Add   ş""".GenerateKeyÂ·f          "".GenerateKey   ş8runtime.writebarrierifaceÂ·f          2runtime.writebarrieriface   ş4runtime.writebarrierptrÂ·f          .runtime.writebarrierptr   ş0math/big.(*Int).BytesÂ·f          *math/big.(*Int).Bytes   ş"".hashToIntÂ·f          "".hashToInt   ş2math/big.(*Int).BitLenÂ·f          ,math/big.(*Int).BitLen   ş*runtime.panicsliceÂ·f          $runtime.panicslice   ş,math/big.(*Int).RshÂ·f          &math/big.(*Int).Rsh   ş&"".fermatInverseÂ·f           "".fermatInverse   ş$math/big.NewIntÂ·f          math/big.NewInt   ş,math/big.(*Int).ExpÂ·f          &math/big.(*Int).Exp   ş,math/big.(*Int).MulÂ·f          &math/big.(*Int).Mul   ş"".VerifyÂ·f          "".Verify   ş,math/big.(*Int).CmpÂ·f          &math/big.(*Int).Cmp   ş:math/big.(*Int).ModInverseÂ·f          4math/big.(*Int).ModInverse   ş"".initÂ·f          "".init   ş(runtime.throwinitÂ·f          "runtime.throwinit   ş math/big.initÂ·f          math/big.init   şio.initÂ·f          io.init   ş*encoding/asn1.initÂ·f          $encoding/asn1.init   ş.crypto/elliptic.initÂ·f          (crypto/elliptic.init   şcrypto.initÂ·f          crypto.init   ş6math/big.(*Int).SetInt64Â·f          0math/big.(*Int).SetInt64   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783             şTgclocalsÂ·44568aa369055d8938d809aa5d80843b              şTgclocalsÂ·9c703c5c7b9c1932c840b69f8ebce236             ş6type..hashfunc."".PublicKey          .type..hash."".PublicKey   ş2type..eqfunc."".PublicKey          *type..eq."".PublicKey   ş,type..alg."".PublicKey              6type..hashfunc."".PublicKey     2type..eqfunc."".PublicKey   şBruntime.gcbits.0x8c88000000000000   Œˆ       ş6go.string."ecdsa.PublicKey" 0  0       ecdsa.PublicKey   6go.string."ecdsa.PublicKey"   şgo.string."X"          X   go.string."X"   şgo.string."Y"          Y   go.string."Y"   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·78ad52f947c0f9e54dd0fb4377b33085         «ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·2c26e9496b1c078fc62b3f021ed30e75         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·533e41f03c38242213357bdf241c642f         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·564befda8e2e8cc7f35f6bc1d3c5e0a6      
   «    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1         
    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·f4b5958521e1cb5f3b2f5fb10ef93ae8         «   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2         ª    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·464a8fa94b68a24c95c5f7d743fa1b72         «*   şBruntime.gcbits.0x8800000000000000   ˆ        ş¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¶    R   func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ôgİz 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¼go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ögo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       >   func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)   ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   º|¶ù 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ”go.string."func(ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ºgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   ştgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool" p  n    .   func(ecdsa.PublicKey, *big.Int, *big.Int) bool   tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   şttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool ¨  ¨   Å 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  tgo.string."func(ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  †go.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   p  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams" h  h    +   func(ecdsa.PublicKey) *elliptic.CurveParams   ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   şhtype.func("".PublicKey) *crypto/elliptic.CurveParams ˜  ˜   ¶ñÓ± 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ngo.string."func(ecdsa.PublicKey) *elliptic.CurveParams"   @  zgo.weak.type.*func("".PublicKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ htype.func("".PublicKey) *crypto/elliptic.CurveParams   p htype.func("".PublicKey) *crypto/elliptic.CurveParams   ˆ  "type."".PublicKey     Btype.*crypto/elliptic.CurveParams   şBruntime.gcbits.0x4884440000000000   H„D      ş&go.string."[]uint8"            []uint8   &go.string."[]uint8"   ştype.[]uint8 X  X   ß~.8                                   runtime.algarray      Bruntime.gcbits.0x4884440000000000   0  &go.string."[]uint8"   @  *go.weak.type.*[]uint8   H  "runtime.zerovalue   P  type.uint8   ş6go.typelink.[]uint8/[]uint8          type.[]uint8   ş~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" x  x    3   func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)   ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   g«¿ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ~go.string."func(ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  go.weak.type.*func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"         G   func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   şºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸    “Rg 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¦go.string."func(ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ìgo.weak.type.*func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  "type."".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş*go.string."PublicKey" (  $    	   PublicKey   *go.string."PublicKey"   şgo.string."Add"          Add   go.string."Add"   şšgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ”    A   func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şÈtype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¸  ¸   ğ\áõ 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  šgo.string."func(*big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  Úgo.weak.type.*func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p¨ Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş$go.string."Double"           Double   $go.string."Double"   şrgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)" p  l    -   func(*big.Int, *big.Int) (*big.Int, *big.Int)   rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   şŒtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) ¨  ¨   3`1
 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  rgo.string."func(*big.Int, *big.Int) (*big.Int, *big.Int)"   @  go.weak.type.*func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p˜ Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ş*go.string."IsOnCurve" (  $    	   IsOnCurve   *go.string."IsOnCurve"   şRgo.string."func(*big.Int, *big.Int) bool" P  L       func(*big.Int, *big.Int) bool   Rgo.string."func(*big.Int, *big.Int) bool"   şXtype.func(*math/big.Int, *math/big.Int) bool        À§ 3                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Rgo.string."func(*big.Int, *big.Int) bool"   @  jgo.weak.type.*func(*math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ Xtype.func(*math/big.Int, *math/big.Int) bool   p˜ Xtype.func(*math/big.Int, *math/big.Int) bool   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.bool   ş$go.string."Params"           Params   $go.string."Params"   şPgo.string."func() *elliptic.CurveParams" P  J       func() *elliptic.CurveParams   Pgo.string."func() *elliptic.CurveParams"   şPtype.func() *crypto/elliptic.CurveParams      ˆ¨"å 3                                                          °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Pgo.string."func() *elliptic.CurveParams"   @  bgo.weak.type.*func() *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ Ptype.func() *crypto/elliptic.CurveParams   pˆ Ptype.func() *crypto/elliptic.CurveParams   ˆ  Btype.*crypto/elliptic.CurveParams   ş4go.string."ScalarBaseMult" 0  .       ScalarBaseMult   4go.string."ScalarBaseMult"   ş\go.string."func([]uint8) (*big.Int, *big.Int)" X  V    "   func([]uint8) (*big.Int, *big.Int)   \go.string."func([]uint8) (*big.Int, *big.Int)"   şbtype.func([]uint8) (*math/big.Int, *math/big.Int)        €Ÿ.l 3                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  \go.string."func([]uint8) (*big.Int, *big.Int)"   @  tgo.weak.type.*func([]uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ btype.func([]uint8) (*math/big.Int, *math/big.Int)   p btype.func([]uint8) (*math/big.Int, *math/big.Int)   ˆ  type.[]uint8     $type.*math/big.Int   ˜  $type.*math/big.Int   ş,go.string."ScalarMult" (  &    
   ScalarMult   ,go.string."ScalarMult"   ş„go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" €  ~    6   func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ştype.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) °  °   ašÙÂ 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  „go.string."func(*big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  °go.weak.type.*func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*math/big.Int     $type.*math/big.Int   ˜  type.[]uint8      $type.*math/big.Int   ¨  $type.*math/big.Int   ş"type."".PublicKey  ¨  ¨   ™ÉZN                                                                                                                                                                                                                                                                   Z  ,type..alg."".PublicKey      Bruntime.gcbits.0x8c88000000000000   0  6go.string."ecdsa.PublicKey"   @  $type.*"".PublicKey   H  "runtime.zerovalue   Ph "type."".PublicKey   x  4type.crypto/elliptic.Curve     go.string."X"      $type.*math/big.Int   ¸  go.string."Y"   È  $type.*math/big.Int   8à "type."".PublicKey   à  *go.string."PublicKey"   è  "go.importpath."".   ğˆ "type."".PublicKey   ˆ  go.string."Add"   ˜  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      ätype.func("".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨  &"".(*PublicKey).Add   °   "".PublicKey.Add   ¸  $go.string."Double"   È  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ¨type.func("".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ø  ,"".(*PublicKey).Double   à  &"".PublicKey.Double   è  *go.string."IsOnCurve"   ø  Xtype.func(*math/big.Int, *math/big.Int) bool   €  ttype.func("".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  2"".(*PublicKey).IsOnCurve     ,"".PublicKey.IsOnCurve   ˜  $go.string."Params"   ¨  Ptype.func() *crypto/elliptic.CurveParams   °  htype.func("".PublicKey) *crypto/elliptic.CurveParams   ¸  ,"".(*PublicKey).Params   À  &"".PublicKey.Params   È  4go.string."ScalarBaseMult"   Ø  btype.func([]uint8) (*math/big.Int, *math/big.Int)   à  ~type.func("".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   è  <"".(*PublicKey).ScalarBaseMult   ğ  6"".PublicKey.ScalarBaseMult   ø  ,go.string."ScalarMult"   ˆ  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)     ºtype.func("".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˜  4"".(*PublicKey).ScalarMult      ."".PublicKey.ScalarMult   ş8go.string."*ecdsa.PublicKey" 8  2       *ecdsa.PublicKey   8go.string."*ecdsa.PublicKey"   ş¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ²% • 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¾go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş–go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)   –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ö&‡? 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  –go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şvgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool" p  p    /   func(*ecdsa.PublicKey, *big.Int, *big.Int) bool   vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   şvtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool ¨  ¨   ›²N¢ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  vgo.string."func(*ecdsa.PublicKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   p  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şpgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams" p  j    ,   func(*ecdsa.PublicKey) *elliptic.CurveParams   pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   şjtype.func(*"".PublicKey) *crypto/elliptic.CurveParams ˜  ˜   Zmdš 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  pgo.string."func(*ecdsa.PublicKey) *elliptic.CurveParams"   @  |go.weak.type.*func(*"".PublicKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   p jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   ˆ  $type.*"".PublicKey     Btype.*crypto/elliptic.CurveParams   ş€go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)   €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   ş€type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   3nÄ7 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  €go.string."func(*ecdsa.PublicKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   fy< 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¨go.string."func(*ecdsa.PublicKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type.*"".PublicKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş$type.*"".PublicKey         €Ğ/ 6                                                                                                                                                                                                  L@  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  8go.string."*ecdsa.PublicKey"   @  6go.weak.type.**"".PublicKey   H  "runtime.zerovalue   P  "type."".PublicKey   8X $type.*"".PublicKey   h€ $type.*"".PublicKey   €  go.string."Add"     Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ætype.func(*"".PublicKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      &"".(*PublicKey).Add   ¨  &"".(*PublicKey).Add   °  $go.string."Double"   À  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ªtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ,"".(*PublicKey).Double   Ø  ,"".(*PublicKey).Double   à  *go.string."IsOnCurve"   ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   ø  vtype.func(*"".PublicKey, *math/big.Int, *math/big.Int) bool   €  2"".(*PublicKey).IsOnCurve   ˆ  2"".(*PublicKey).IsOnCurve     $go.string."Params"      Ptype.func() *crypto/elliptic.CurveParams   ¨  jtype.func(*"".PublicKey) *crypto/elliptic.CurveParams   °  ,"".(*PublicKey).Params   ¸  ,"".(*PublicKey).Params   À  4go.string."ScalarBaseMult"   Ğ  btype.func([]uint8) (*math/big.Int, *math/big.Int)   Ø  €type.func(*"".PublicKey, []uint8) (*math/big.Int, *math/big.Int)   à  <"".(*PublicKey).ScalarBaseMult   è  <"".(*PublicKey).ScalarBaseMult   ğ  ,go.string."ScalarMult"   €  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  ¼type.func(*"".PublicKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)     4"".(*PublicKey).ScalarMult   ˜  4"".(*PublicKey).ScalarMult   şTgclocalsÂ·3280bececceccd33cb74587feedb1f9f           şTgclocalsÂ·2dc77d960dd3e4b3de2361f9cbd75783             şTgclocalsÂ·65526a5f07004f02424fe51b799cdd23               
    şTgclocalsÂ·fa7203fd5ed88aea99b7be572f707eb0                  ş8type..hashfunc."".PrivateKey          0type..hash."".PrivateKey   ş4type..eqfunc."".PrivateKey          ,type..eq."".PrivateKey   ş.type..alg."".PrivateKey              8type..hashfunc."".PrivateKey     4type..eqfunc."".PrivateKey   şBruntime.gcbits.0x8c88c88888000000   ŒˆÈˆˆ    ş8go.string."ecdsa.PrivateKey" 8  2       ecdsa.PrivateKey   8go.string."ecdsa.PrivateKey"   şgo.string."D"          D   go.string."D"   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·be52d99fd4fc187ec6a3cd1eab5661d9         ª   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·d0639bedff7ffedcd56695753d30706e         «ª  şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6e5d4a330d25067342b1b461a5d19024      
   *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·dd6da6b6c0a8ea1724ec8c8531209fd3         «*   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·8d11a518189555fd7f3bac3cc6ad264c         *    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·dafc2a4ed1eccf20e0ba3ca784d254a7         «*   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·06cab038d51064a089bda21fa03e00f7             şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·743023cec9b4b515d11a8fbfd57d92fa         «   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·9f0d5ba6770c4a1ed4fa771547e96df1         
    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·fb6dce094c1dd234d359f74ad2ce663f         «
   şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·6f36ab01c3b1e9831d2d7a8e3c4180c2         ª    şTgclocalsÂ·d64e51a4c4bfeaa840e480961ec6b0b3              şTgclocalsÂ·820c449159202a11cc0e8f118b89b1ba         «ª   ş¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" ¸  ¸    S   func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   ü¼IÍ 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¾go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  øgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş–go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"       ?   func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)   –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   şªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   Œÿ‰x 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  –go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¼go.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şvgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool" p  p    /   func(ecdsa.PrivateKey, *big.Int, *big.Int) bool   vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şvtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool ¨  ¨   "‚ù 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  vgo.string."func(ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  ˆgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   p  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şpgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams" p  j    ,   func(ecdsa.PrivateKey) *elliptic.CurveParams   pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   şjtype.func("".PrivateKey) *crypto/elliptic.CurveParams ˜  ˜   Ó'î 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  pgo.string."func(ecdsa.PrivateKey) *elliptic.CurveParams"   @  |go.weak.type.*func("".PrivateKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   p jtype.func("".PrivateKey) *crypto/elliptic.CurveParams   ˆ  $type."".PrivateKey     Btype.*crypto/elliptic.CurveParams   ş€go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  z    4   func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)   €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş€type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   |Œ¤» 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  €go.string."func(ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ’go.weak.type.*func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   ş¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¢    H   func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   ¥ÑX 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¨go.string."func(ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Îgo.weak.type.*func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  $type."".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş,go.string."PrivateKey" (  &    
   PrivateKey   ,go.string."PrivateKey"   ş$type."".PrivateKey  €  €   A;!–                                                                                                                                                                                                                                                V  .type..alg."".PrivateKey      Bruntime.gcbits.0x8c88c88888000000   0  8go.string."ecdsa.PrivateKey"   @  &type.*"".PrivateKey   H  "runtime.zerovalue   Ph $type."".PrivateKey   x  "type."".PublicKey     go.string."D"      $type.*math/big.Int   8¸ $type."".PrivateKey   ¸  ,go.string."PrivateKey"   À  "go.importpath."".   Èà $type."".PrivateKey   à  go.string."Add"   ğ  Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ø  ætype.func("".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   €  ("".(*PrivateKey).Add   ˆ  """.PrivateKey.Add     $go.string."Double"      Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ¨  ªtype.func("".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   °  ."".(*PrivateKey).Double   ¸  ("".PrivateKey.Double   À  *go.string."IsOnCurve"   Ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   Ø  vtype.func("".PrivateKey, *math/big.Int, *math/big.Int) bool   à  4"".(*PrivateKey).IsOnCurve   è  ."".PrivateKey.IsOnCurve   ğ  $go.string."Params"   €  Ptype.func() *crypto/elliptic.CurveParams   ˆ  jtype.func("".PrivateKey) *crypto/elliptic.CurveParams     ."".(*PrivateKey).Params   ˜  ("".PrivateKey.Params      4go.string."ScalarBaseMult"   °  btype.func([]uint8) (*math/big.Int, *math/big.Int)   ¸  €type.func("".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   À  >"".(*PrivateKey).ScalarBaseMult   È  8"".PrivateKey.ScalarBaseMult   Ğ  ,go.string."ScalarMult"   à  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   è  ¼type.func("".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ğ  6"".(*PrivateKey).ScalarMult   ø  0"".PrivateKey.ScalarMult   ş:go.string."*ecdsa.PrivateKey" 8  4       *ecdsa.PrivateKey   :go.string."*ecdsa.PrivateKey"   şÀgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)" À  º    T   func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)   Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   şètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) À  À   w©Kı 3                                                                                °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Àgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  úgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p° ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ¸  $type.*math/big.Int   ş˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)" ˜  ’    @   func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)   ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   ş¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int) °  °   ;šN 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ˜go.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) (*big.Int, *big.Int)"   @  ¾go.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   p  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      $type.*math/big.Int   ¨  $type.*math/big.Int   şxgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool" x  r    0   func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool   xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   şxtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool ¨  ¨   ^IŒ? 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  xgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int) bool"   @  Šgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   H  "runtime.zerovalue   Xˆ xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   p  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.bool   şrgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams" p  l    -   func(*ecdsa.PrivateKey) *elliptic.CurveParams   rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   şltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams ˜  ˜   “â 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  rgo.string."func(*ecdsa.PrivateKey) *elliptic.CurveParams"   @  ~go.weak.type.*func(*"".PrivateKey) *crypto/elliptic.CurveParams   H  "runtime.zerovalue   Xˆ ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   p ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   ˆ  &type.*"".PrivateKey     Btype.*crypto/elliptic.CurveParams   şhgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey" h  b    (   func(*ecdsa.PrivateKey) crypto.PublicKey   hgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey"   şTtype.func(*"".PrivateKey) crypto.PublicKey ˜  ˜   5­EK 3                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  hgo.string."func(*ecdsa.PrivateKey) crypto.PublicKey"   @  fgo.weak.type.*func(*"".PrivateKey) crypto.PublicKey   H  "runtime.zerovalue   Xˆ Ttype.func(*"".PrivateKey) crypto.PublicKey   p Ttype.func(*"".PrivateKey) crypto.PublicKey   ˆ  &type.*"".PrivateKey     *type.crypto.PublicKey   ş‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)" €  |    5   func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)   ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   ş‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int) ¨  ¨   ßÒ 3                                                                    °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ‚go.string."func(*ecdsa.PrivateKey, []uint8) (*big.Int, *big.Int)"   @  ”go.weak.type.*func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   p˜ ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     type.[]uint8   ˜  $type.*math/big.Int      $type.*math/big.Int   şªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)" ¨  ¤    I   func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)   ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   ş¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int) ¸  ¸   ò	 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ªgo.string."func(*ecdsa.PrivateKey, *big.Int, *big.Int, []uint8) (*big.Int, *big.Int)"   @  Ğgo.weak.type.*func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   H  "runtime.zerovalue   Xˆ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   p¨ ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ˆ  &type.*"".PrivateKey     $type.*math/big.Int   ˜  $type.*math/big.Int      type.[]uint8   ¨  $type.*math/big.Int   °  $type.*math/big.Int   ş¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)" °  °    O   func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   ş¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) ¸  ¸   ¥"Ó 3                                                                            °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  ¶go.string."func(*ecdsa.PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ´go.weak.type.*func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   H  "runtime.zerovalue   Xˆ ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   p¨ ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ˆ  &type.*"".PrivateKey     type.io.Reader   ˜  type.[]uint8      ,type.crypto.SignerOpts   ¨  type.[]uint8   °  type.error   ş$go.string."Public"           Public   $go.string."Public"   şFgo.string."func() crypto.PublicKey" @  @       func() crypto.PublicKey   Fgo.string."func() crypto.PublicKey"   ş8type.func() crypto.PublicKey      T¿, 3                                                          °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Fgo.string."func() crypto.PublicKey"   @  Jgo.weak.type.*func() crypto.PublicKey   H  "runtime.zerovalue   Xˆ 8type.func() crypto.PublicKey   pˆ 8type.func() crypto.PublicKey   ˆ  *type.crypto.PublicKey   ş go.string."Sign"           Sign    go.string."Sign"   şgo.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   Š    <   func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   go.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   ş‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error) °  °   —@` 3                                                                        °  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  go.string."func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)"   @  ”go.weak.type.*func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   H  "runtime.zerovalue   Xˆ ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   p  ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ˆ  type.io.Reader     type.[]uint8   ˜  ,type.crypto.SignerOpts      type.[]uint8   ¨  type.error   ş&type.*"".PrivateKey  €  €   Ñƒ¿Ê 6                                                                                                                                                                                                                                                  `@  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  :go.string."*ecdsa.PrivateKey"   @  8go.weak.type.**"".PrivateKey   H  "runtime.zerovalue   P  $type."".PrivateKey   8X &type.*"".PrivateKey   h€ &type.*"".PrivateKey   €  go.string."Add"     Ètype.func(*math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   ˜  ètype.func(*"".PrivateKey, *math/big.Int, *math/big.Int, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)      ("".(*PrivateKey).Add   ¨  ("".(*PrivateKey).Add   °  $go.string."Double"   À  Œtype.func(*math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   È  ¬type.func(*"".PrivateKey, *math/big.Int, *math/big.Int) (*math/big.Int, *math/big.Int)   Ğ  ."".(*PrivateKey).Double   Ø  ."".(*PrivateKey).Double   à  *go.string."IsOnCurve"   ğ  Xtype.func(*math/big.Int, *math/big.Int) bool   ø  xtype.func(*"".PrivateKey, *math/big.Int, *math/big.Int) bool   €  4"".(*PrivateKey).IsOnCurve   ˆ  4"".(*PrivateKey).IsOnCurve     $go.string."Params"      Ptype.func() *crypto/elliptic.CurveParams   ¨  ltype.func(*"".PrivateKey) *crypto/elliptic.CurveParams   °  ."".(*PrivateKey).Params   ¸  ."".(*PrivateKey).Params   À  $go.string."Public"   Ğ  8type.func() crypto.PublicKey   Ø  Ttype.func(*"".PrivateKey) crypto.PublicKey   à  ."".(*PrivateKey).Public   è  ."".(*PrivateKey).Public   ğ  4go.string."ScalarBaseMult"   €  btype.func([]uint8) (*math/big.Int, *math/big.Int)   ˆ  ‚type.func(*"".PrivateKey, []uint8) (*math/big.Int, *math/big.Int)     >"".(*PrivateKey).ScalarBaseMult   ˜  >"".(*PrivateKey).ScalarBaseMult      ,go.string."ScalarMult"   °  type.func(*math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   ¸  ¾type.func(*"".PrivateKey, *math/big.Int, *math/big.Int, []uint8) (*math/big.Int, *math/big.Int)   À  6"".(*PrivateKey).ScalarMult   È  6"".(*PrivateKey).ScalarMult   Ğ   go.string."Sign"   à  ‚type.func(io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   è  ¢type.func(*"".PrivateKey, io.Reader, []uint8, crypto.SignerOpts) ([]uint8, error)   ğ  *"".(*PrivateKey).Sign   ø  *"".(*PrivateKey).Sign   şBgo.string."*ecdsa.ecdsaSignature" @  <       *ecdsa.ecdsaSignature   Bgo.string."*ecdsa.ecdsaSignature"   ş.type.*"".ecdsaSignature  X  X   ©
ÛK 6                                @  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  Bgo.string."*ecdsa.ecdsaSignature"   @  @go.weak.type.**"".ecdsaSignature   H  "runtime.zerovalue   P  ,type."".ecdsaSignature   ş@go.string."ecdsa.ecdsaSignature" @  :       ecdsa.ecdsaSignature   @go.string."ecdsa.ecdsaSignature"   şgo.string."R"          R   go.string."R"   şgo.string."S"          S   go.string."S"   ş4go.string."ecdsaSignature" 0  .       ecdsaSignature   4go.string."ecdsaSignature"   ş,type."".ecdsaSignature  à  à   DÁ)e                                                                                                  P  runtime.algarray      Bruntime.gcbits.0x8800000000000000   0  @go.string."ecdsa.ecdsaSignature"   @  .type.*"".ecdsaSignature   H  "runtime.zerovalue   Ph ,type."".ecdsaSignature   h  go.string."R"   x  $type.*math/big.Int     go.string."S"      $type.*math/big.Int   8¸ ,type."".ecdsaSignature   ¸  4go.string."ecdsaSignature"   À  "go.importpath."".   Èà ,type."".ecdsaSignature   ş$go.string."crypto"           crypto   $go.string."crypto"   ş*go.importpath.crypto.            $go.string."crypto"   ş&go.string."runtime"            runtime   &go.string."runtime"   ş,go.importpath.runtime.            &go.string."runtime"   şgo.string."io"          io   go.string."io"   ş"go.importpath.io.            go.string."io"   ş6go.string."crypto/elliptic" 0  0       crypto/elliptic   6go.string."crypto/elliptic"   ş<go.importpath.crypto/elliptic.            6go.string."crypto/elliptic"   ş2go.string."encoding/asn1" 0  ,       encoding/asn1   2go.string."encoding/asn1"   ş8go.importpath.encoding/asn1.            2go.string."encoding/asn1"   ş(go.string."math/big" (  "       math/big   (go.string."math/big"   ş.go.importpath.math/big.            (go.string."math/big"   ş4type..hash."".PublicKeyÂ·f          .type..hash."".PublicKey   ş(runtime.interhashÂ·f          "runtime.interhash   ş$runtime.memhashÂ·f          runtime.memhash   ş0type..eq."".PublicKeyÂ·f          *type..eq."".PublicKey   ş$runtime.ifaceeqÂ·f          runtime.ifaceeq   ş,"".(*PublicKey).AddÂ·f          &"".(*PublicKey).Add   ş&"".PublicKey.AddÂ·f           "".PublicKey.Add   ş2"".(*PublicKey).DoubleÂ·f          ,"".(*PublicKey).Double   ş,"".PublicKey.DoubleÂ·f          &"".PublicKey.Double   ş8"".(*PublicKey).IsOnCurveÂ·f          2"".(*PublicKey).IsOnCurve   ş2"".PublicKey.IsOnCurveÂ·f          ,"".PublicKey.IsOnCurve   ş2"".(*PublicKey).ParamsÂ·f          ,"".(*PublicKey).Params   ş,"".PublicKey.ParamsÂ·f          &"".PublicKey.Params   şB"".(*PublicKey).ScalarBaseMultÂ·f          <"".(*PublicKey).ScalarBaseMult   ş<"".PublicKey.ScalarBaseMultÂ·f          6"".PublicKey.ScalarBaseMult   ş:"".(*PublicKey).ScalarMultÂ·f          4"".(*PublicKey).ScalarMult   ş4"".PublicKey.ScalarMultÂ·f          ."".PublicKey.ScalarMult   ş6type..hash."".PrivateKeyÂ·f          0type..hash."".PrivateKey   ş2type..eq."".PrivateKeyÂ·f          ,type..eq."".PrivateKey   ş."".(*PrivateKey).AddÂ·f          ("".(*PrivateKey).Add   ş("".PrivateKey.AddÂ·f          """.PrivateKey.Add   ş4"".(*PrivateKey).DoubleÂ·f          ."".(*PrivateKey).Double   ş."".PrivateKey.DoubleÂ·f          ("".PrivateKey.Double   ş:"".(*PrivateKey).IsOnCurveÂ·f          4"".(*PrivateKey).IsOnCurve   ş4"".PrivateKey.IsOnCurveÂ·f          ."".PrivateKey.IsOnCurve   ş4"".(*PrivateKey).ParamsÂ·f          ."".(*PrivateKey).Params   ş."".PrivateKey.ParamsÂ·f          ("".PrivateKey.Params   şD"".(*PrivateKey).ScalarBaseMultÂ·f          >"".(*PrivateKey).ScalarBaseMult   ş>"".PrivateKey.ScalarBaseMultÂ·f          8"".PrivateKey.ScalarBaseMult   ş<"".(*PrivateKey).ScalarMultÂ·f          6"".(*PrivateKey).ScalarMult   ş6"".PrivateKey.ScalarMultÂ·f          0"".PrivateKey.ScalarMult   ş"runtime.zerovalue      ÿÿgo13ld 